# Звіт з лабораторної роботи: Дослідження механізмів синхронізації в мультипотоковому програмуванні на Java.

# Виконав: Ст. гр. СауМ-24-1 Лобанов Кирило Сергійович

Цей звіт описує лабораторну роботу, присвячену реалізації та дослідженню механізмів синхронізації в мультипотоковому програмуванні на мові Java. Проект включає п’ять симуляцій: м’ютекс, семафор, атомарна змінна, пул потоків та симуляція роботи касирів із чергами. У звіті наведено опис структури проекту, функціональності кожного компонента, результатів виконання та висновків щодо використання механізмів синхронізації.

Мультипотоковість є ключовою концепцією сучасного програмування, що дозволяє виконувати кілька задач паралельно, підвищуючи ефективність використання ресурсів. Однак мультипотокові програми потребують синхронізації для уникнення таких проблем, як умови гонки, взаємне блокування (deadlock) або голодування потоків (starvation). У цій лабораторній роботі створено консольну програму на Java, яка демонструє основні механізми синхронізації: м’ютекси {ReentrantLock}, семафори {Semaphore}, атомарні змінні {AtomicInteger}, пул потоків {ExecutorService} та черги {BlockingQueue}. Програма дозволяє користувачу взаємодіяти через меню, обираючи різні симуляції та вводячи параметри для їх виконання.

# Мета роботи
Метою лабораторної роботи є:
   Вивчення основних механізмів синхронізації в мультипотоковому програмуванні.
   Практична реалізація симуляцій, що демонструють роботу м’ютексів, семафорів, атомарних змінних, пулів потоків та черг.
   Аналіз поведінки потоків за різних умов та параметрів.

# Опис програми

# Структура проекту
Програма складається з шести основних класів, розташованих у пакеті main.java.com.example.multithreadingsync:
    {Main} --- точка входу, ініціалізує меню.
    {MenuHandler} --- керує консольним меню та викликає симуляції.
   {MutexSimulator} --- демонструє синхронізацію за допомогою м’ютекса.
   {SemaphoreSimulator} --- ілюструє контроль доступу через семафор.
   {AtomicSimulator} --- показує атомарні операції над змінною.
   {ThreadPoolSimulator} --- демонструє роботу пулів потоків.
   {CashierSimulation} --- моделює систему черг із касирами.


# Опис компонентів

Клас Main є точкою входу програми. Він створює об’єкт MenuHandler і викликає метод showMenu() для запуску інтерфейсу користувача.

Клас MenuHandler відображає консольне меню з опціями для запуску симуляцій. Користувач може обрати одну з п’яти симуляцій або завершити програму. Вибір обробляється через конструкцію \texttt{switch-case}.

Клас MutexSimulator демонструє синхронізацію за допомогою м’ютекса ReentrantLock. Користувач вводить кількість потоків n та діапазон часу сну t1, t2. Кожен потік захоплює м’ютекс, спить випадковий час і звільняє м’ютекс.

Клас SemaphoreSimulator ілюструє використання семафора Semaphore з дозволом на 4 одночасних доступи. Користувач вводить параметри аналогічно до MutexSimulator.

AtomicSimulator демонструє атомарні операції над змінною типу AtomicInteger. Користувач може збільшувати, зменшувати, встановлювати або переглядати значення змінної.

Клас ThreadPoolSimulator показує роботу пулів потоків ExecutorService. Користувач обирає тип пулу (фіксований або кешований) та кількість задач.

Клас CashierSimulation моделює систему черг у магазині. Користувач вводить кількість кас і клієнтів, а програма розподіляє клієнтів по найкоротших чергах, використовуючи BlockingQueue.

# Результати виконання
Нижче наведено приклади виведення для кожної симуляції.

М’ютекс
Вхідні дані: n=3, t1=100, t2=500.
Кількість потоків: 3
t1 (мс): 100
t2 (мс): 500
Потік-1 чекає м'ютекс...
Потік-1 захопив м'ютекс.
Потік-2 чекає м'ютекс...
Потік-3 чекає м'ютекс...
Потік-1 звільняє м'ютекс.
Потік-2 захопив м'ютекс.
Потік-2 звільняє м'ютекс.
Потік-3 захопив м'ютекс.
Потік-3 звільняє м'ютекс.

Семафор
Вхідні дані: n=6, t1=100, {t2=300.
Кількість потоків: 6
t1 (мс): 100
t2 (мс): 300
Потік-1 чекає семафор...
Потік-1 отримав семафор.
Потік-2 чекає семафор...
Потік-2 отримав семафор.
Потік-3 чекає семафор...
Потік-3 отримав семафор.
Потік-4 чекає семафор...
Потік-4 отримав семафор.
Потік-5 чекає семафор...
Потік-6 чекає семафор...
Потік-1 звільняє семафор.
Потік-5 отримав семафор.

Атомарна змінна

1. Збільшити
2. Зменшити
3. Встановити значення
4. Поточне значення
0. Назад
1
Нове значення: 1
1
Нове значення: 2
4
Поточне значення: 2

Пул потоків
Вхідні дані: type=1, n=6.
Тип (1 - fixed, 2 - cached): 1
Кількість потоків для виконання: 6
Потік-1 працює...
Потік-2 працює...
Потік-3 працює...
Потік-4 працює...
Потік-1 завершив.
Потік-5 працює...
Потік-2 завершив.
Потік-6 працює...


Вільна каса
Вхідні дані: cashierCount=2, clients=4.
Введіть кількість кас: 2
Кількість клієнтів: 4
Усі клієнти розподілені по чергам.
Каса 1 обслуговує Клієнт-1
Каса 2 обслуговує Клієнт-2
Каса 1 обслуговує Клієнт-3
Каса 2 обслуговує Клієнт-4


# Аналіз результатів
   М’ютекс: Забезпечує взаємовиключення, дозволяючи лише одному потоку перебувати в критичній секції. Використання ReentrantLock гарантує безпечне звільнення ресурсів через блок finally.
   Семафор: Дозволяє обмежити доступ до ресурсів (тут 4 одночасних потоки). Це корисно для задач із фіксованою кількістю ресурсів.
   Атомарна змінна: AtomicInteger забезпечує швидкі операції без явних блокувань, ідеально для простих лічильників.
   Пул потоків: Фіксований пул обмежує кількість потоків, економлячи ресурси, тоді як кешований пул гнучкіший, але може створювати більше потоків.
   Вільна каса: Використання BlockingQueue ефективно моделює задачу "виробник-споживач". Розподіл клієнтів по найкоротших чергах імітує реальну поведінку.

# Висновки
У ході лабораторної роботи було реалізовано та протестовано п’ять механізмів синхронізації в мультипотоковому програмуванні на Java. Кожен механізм має свої переваги:
    ReentrantLock підходить для задач із взаємовиключенням.
    Semaphore ефективний для обмеження доступу до ресурсів.
    AtomicInteger оптимальний для швидких атомарних операцій.
    ExecutorService спрощує управління потоками.
    BlockingQueue ідеально для задач із чергами.
Програма є модульною, легко розширюваною та демонструє ключові аспекти мультипотоковості. Уникнення проблем, таких як умови гонки чи взаємне блокування, досягнуто завдяки правильному використанню синхронізаційних примітивів.

